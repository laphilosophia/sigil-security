---
description: Sigil-Security TypeScript code quality standards. Enforces SOLID, KISS, YAGNI, DRY principles and senior-level best practices.
globs: "**/*.ts"
alwaysApply: false
---

# TypeScript Code Quality Rules

## Core Principles

- **KISS:** Prefer simple, readable implementations. Crypto code must be auditable by security reviewers.
- **YAGNI:** Only implement what the specification defines. No speculative features or "nice-to-have" abstractions.
- **DRY:** Extract shared logic into utility functions. Token parsing, encoding, and validation share buffer ops -- centralize them.
- **SOLID:**
  - **S:** Each file has one responsibility (e.g., `crypto.ts` = crypto ops, `token.ts` = token model)
  - **O:** Policy layers are open for extension (custom validators) but closed for modification
  - **L:** All adapters are substitutable -- same interface, different framework
  - **I:** Small, focused interfaces (`TokenGenerator`, `TokenValidator`, `PolicyValidator`)
  - **D:** Core depends on abstractions (WebCrypto interface), not concrete implementations

## TypeScript Standards

- **Strict mode:** `"strict": true` in all tsconfig files
- **No `any`:** Use `unknown` + type narrowing. Exception: framework adapter boundaries with proper runtime validation
- **Explicit return types** on all exported functions
- **`readonly`** on all properties that should not be mutated after creation
- **`as const`** for literal constants (crypto parameters, config defaults)
- **Branded types** for security-critical values: `type TokenString = string & { readonly __brand: 'Token' }`
- **Result pattern** over exceptions for validation: `{ valid: true, ... } | { valid: false, reason: string }`

## Function Design

```typescript
// GOOD: Pure, typed, single-purpose
export function validateTTL(
  tokenTimestamp: number,
  ttlMs: number,
  graceWindowMs: number,
  now: number = Date.now(),
): { withinTTL: boolean; inGraceWindow: boolean } { ... }

// BAD: Impure, side-effects, multiple concerns
export function validate(req: any): boolean { ... }
```

- Functions in `core` MUST be pure (deterministic, no side-effects except ephemeral cache)
- Accept `now` parameter for testability -- never hardcode `Date.now()` deep in logic
- Max function length: ~40 lines. Extract sub-operations if longer.
- Max file length: ~300 lines. Split into focused modules if longer.

## Error Handling

- Core returns `Result` objects, NEVER throws for validation failures
- Adapter layer catches and translates to HTTP responses
- Unexpected errors (crypto failures) may throw -- callers must handle
- No empty catch blocks. No swallowed errors.

## Naming Conventions

- Files: `kebab-case.ts` (e.g., `nonce-cache.ts`, `fetch-metadata.ts`)
- Types/Interfaces: `PascalCase` (e.g., `ValidationResult`, `TokenConfig`)
- Functions: `camelCase`, verb-first (e.g., `generateToken`, `validateMAC`, `deriveKey`)
- Constants: `UPPER_SNAKE_CASE` (e.g., `NONCE_SIZE`, `MAX_TOKEN_TTL_MS`)
- Private: `_prefixed` only if absolutely needed, prefer module-scoped

## Testing Expectations

- Every exported function has unit tests
- Test file mirrors source: `src/token.ts` -> `__tests__/token.test.ts`
- Test names: `describe('functionName')` -> `it('should [behavior] when [condition]')`
- Use `vitest` -- no jest
- Security tests: replay, fuzzing, boundary values, malformed input
- Benchmark tests for crypto operations (target: validation < 50us)

## Dependencies

- `sigil-core`: ZERO runtime dependencies. WebCrypto only.
- `sigil-policy`: depends only on `@sigil-security/core`
- `sigil-runtime`: peer dependencies on framework packages (express, fastify, etc.)
- Dev dependencies: `vitest`, `tsup`, `typescript`, `eslint`, `prettier`
- NEVER add a dependency without explicit justification. Prefer standard APIs.
